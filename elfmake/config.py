"""ElfMake module providing configuration classes."""
import env
import imp
import elfmake.io as io
import os.path
import sys

config_list = []	# list of configuration modules
updated = False
in_config = False
win_list = ['win32', 'win64', 'cygwin']


def host():
	"""Return a string identifying the host platform.""" 
	info = os.uname()
	return "%s %s %s %s" % (info[0], info[1], info[2], info[4])

def register(name, config):
	"""Function used to register a configuration."""
	config_list.append((name, config))


def load(do_config):
	"""Called to load the configuration file.
	
	do_config informs it is a load for configuration and
	therefore do not alert user for incompatibility."""
	cpath = env.topdir / "config.py"
	if cpath.exists():
		
		# load the configuration
		mod = imp.load_source('config.py', str(cpath))
		env.confenv.map = mod.__dict__
		
		# check host compatibility
		try:
			h = env.confenv.map['ELF_HOST']
			if h <> None and h <> host():
				
				# warn if we are not in configuration
				if not do_config:
					print "WARNING: config.py for a different host found!\nReconfigure it with ./make.py config"
					
				# reset configuration else
				else:
					env.confenv.map = { }

		except KeyError, e:
			pass

def is_set(id):
	"""Test if a configuration item is set (exists, not None, not empty string, not 0)."""
	try:
		return env.confenv.map[id]
	except KeyError, e:
		return False 

def set_if(id, fun):
	"""Set a configuration item if it is not set. To obtain the value, call the function fun."""
	if not is_set(id):
		env.confenv.set(id, fun())
		global updated
		updated = True

def make(ctx = io.Context()):
	"""Build a configuration."""
	global in_config
	
	# enable config mode
	in_config = True

	# look for a build path
	bpath = env.elfenv["BPATH"]
	if bpath:
		env.confenv["BPATH"] = bpath

	# builtin configuration
	global win_list
	set_if("IS_WINDOWS", lambda : sys.platform in win_list)
	set_if("IS_UNIX", lambda : sys.platform not in win_list)

	# launch module configuration
	for (n, f) in config_list:
		f(ctx)
	
	# if needed, output the configuration file
	if updated:
		env.confenv.set("ELF_HOST", host())
		f = open(str(env.topdir / 'config.py'), "w")
		f.write("# generated by ElfMake\n")
		f.write("# You're ALLOWED modifying this file to tune or complete your configuration\n")
		for k in env.confenv.map:
			if not k.startswith("__"):
				f.write("%s = %s\n" % (k, repr(env.confenv.map[k])))
		f.close()

	# disable config mode
	in_config = False


def find_program(label, var, progs, paths = [], syspath = True, sysfirst = True, ctx = io.Context()):
	"""Find the path of a program and display associated message.
	
	The label is displayed during the look-up, one of progs
	is look in the given paths including system path if syspath is True.
	If sysfirst is true, look system paths first.
	
	If the variable var already exists and is set, do nothing.
	Else store the result in configuration environment."""
	
	# in config mode?
	global in_config
	if not in_config:
		register (label, lambda : find_program(label, var, progs, paths, syspath, sysfirst))
		return
	
	# already exists?
	try:
		path = env.confenv.map[var]
		if path:
			return False
	except KeyError, e:
		pass
	
	# ensure we have a list of programs
	if not isinstance(progs, list):
		progs = [str(progs)]
	
	# include system paths
	if syspath:
		spaths = os.getenv("PATH").split(os.pathsep)
		if sysfirst:
			lpaths = spaths + paths
		else:
			lpaths = paths + spaths
	else:
		lpaths = paths
	
	# lookup
	ctx.print_action(label)
	fpath = None
	for path in lpaths:
		for prog in progs:
			ppath = os.path.join(path, prog)
			if os.access(ppath, os.X_OK):
				if path in paths:
					fpath = ppath
				else:
					fpath = prog
				break
	
	# process result
	env.confenv.set(var, fpath)
	if fpath:
		ctx.print_action_success("found: %s" % fpath)
		global updated
		updated = True
	else:
		ctx.print_action_failure("not found!")

